<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>写一个自己的Unix Shell（2）将读入的字符变成命令 | Lcf&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <!-- <link rel="icon" href="favicon.ico"> -->
    <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAACl1JREFUeF7t2L2u3FcVhvE9Z05ObExwREqE0tHwJXEHKERCNDFIiMvgCrgHOhp6LiARIjR8JKkoEIqQEEVEkGLEl6id4zN/NEcKSmWf2exizXp/J6Vnba/3eZcfj7MbP/nZNvwggEAkgR0BRPYuNAK3BAjAISAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIILl90BAjADSAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIILl90BAjADSAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIILl90BAjADSAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIILl90BAjADSAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIILl90BAjADSAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIILl90BAjADSAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIILl90BAjADSAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIILl90BAjADSAQTIAAgssXHQECcAMIBBMggODyRUeAANwAAsEECCC4fNERIAA3gEAwAQIIKP/yYjeO/53yc9i2cbNtp4z47BkSIIAzLO3klZ98PMZhG3d2wPEP/n4/xtULJ/9WBs6LAAGcV1933vb49/22bePe5eX44Ve/NL742c+M68Nh7HbP/iZwO7Pfj9//6z/jp3/6YBy/CfjpS4AAmnZ7K4DDNh7euxp/+P63x6svPTgp6W8e/2O8/tavx/XNza00aOAkfGfzYQI4m6pOW/QTAXzu3tV4543XxtdeeflO3wAOh21c7S/GWx9+NL779rvj6c02jl8aCOA0/ufyaQI4l6ZO3PPTAnjv0bfGVz7/8Pbr/MVz/glw/B9/+91u/PzDx+PR2++MawI4kfx5fZwAzquvO2/7fwvgr4/Ho18QwJ2Bn+kHCeBMi3ve2gTwPEJ+/UiAAJreAQE0LXZxLAJYDLTKcwRQpYnaexBA7X6mtyOAaXRRgwTQtG4CaFrs4lgEsBholecIoEoTtfcggNr9TG9HANPoogYJoGndBNC02MWxCGAx0CrPEUCVJmrvQQC1+5nejgCm0UUNEkDTugmgabGLYxHAYqBVniOAKk3U3oMAavczvR0BTKOLGiSApnUTQNNiF8cigMVAqzxHAFWaqL0HAdTuZ3o7AphGFzVIAE3rJoCmxS6ORQCLgVZ5jgCqNFF7DwKo3c/0dgQwjS5qkACa1k0ATYtdHIsAFgOt8hwBVGmi9h4EULuf6e0IYBpd1CABNK2bAJoWuzgWASwGWuU5AqjSRO09CKB2P9PbEcA0uqhBAmhaNwE0LXZxLAJYDLTKcwRQpYnaexBA7X6mtyOAaXRRgwTQtG4CaFrs4lgEsBholecIoEoTtfcggNr9TG9HANPoogYJoGndBNC02MWxCGAx0CrPEUCVJmrvQQC1+5nejgCm0UUNEkDTugmgabGLYxHAYqBVniOAKk3U3oMAavczvR0BTKOLGiSApnUTQNNiF8cigMVAqzxHAFWaqL0HAdTuZ3o7AphGFzVIAE3rJoCmxS6ORQCLgVZ5jgCqNFF7DwKo3c/0dgQwjS5qkACa1k0ATYtdHIsAFgOt8hwBVGmi9h4EULuf6e0IYBpd1CABNK2bAJoWuzgWASwGWuU5AqjSRO09CKB2P9PbEcA0uqhBAmhaNwE0LXZxLAJYDLTKcwRQpYnaexBA7X6mtyOAaXRRgwTQtG4CaFrs4lgEsBholecIoEoTtfcggNr9TG9HANPoogYJoGndBNC02MWxCGAx0CrPEUCVJmrvQQC1+5nejgCm0UUNEkDTugmgabGLYxHAYqBVniOAKk3U3oMAavczvR0BTKOLGiSApnUTQNNiF8cigMVAqzxHAFWaqL0HAdTuZ3o7AphGFzVIAE3rJoCmxS6ORQCLgVZ5jgCqNFF7DwKo3c/0dgQwjS5qkACa1k0ATYtdHIsAFgOt8hwBVGmi9h4EULuf6e0IYBpd1CABNK2bAJoWuzgWASwGWuU5AqjSRO09CKB2P9PbEcA0uqhBAmhaNwE0LXZxLAJYDLTKcwRQpYnaexBA7X6mtyOAaXRRgwTQtG4CaFrs4lgEsBholecIoEoTtfcggNr9TG9HANPoogYJoGndBNC02MWxCGAx0CrPEUCVJmrvQQC1+5nejgCm0UUNEkDTugmgabGLYxHAYqBVniOAKk3U3oMAavczvR0BTKOLGiSApnUTQNNiF8cigMVAqzxHAFWaqL0HAdTuZ3o7AphGFzVIAE3rJoCmxS6ORQCLgVZ5jgCqNFF7DwKo3c/0dgQwjS5qkACa1k0ATYtdHIsAFgOt8hwBVGmi9h4EULuf6e0IYBpd1CABNK2bAJoWuzgWASwGWuU5AqjSRO09CKB2P9PbEcA0uqhBAmhaNwE0LXZxLAJYDLTKc58WwG/feG18/ZWXx8c3h7E7/sIzfg7bNl7c78ebf/lofO+X746nN9vtzFYlmD2WEiCApTjrPPaJAB7euxp//MF3xhce3D9puff+9s/xzTd/Na5vbsZutyOAk+idz4cJ4Hy6OmnTWwFs27j/wuX40Te+PF596cG4Phy/ATz7K8DxG8D9y/343d//PX78/p/Hzebv/pPAn9mHCeDMCjt53eOf3ydPxjhsYzzn6///3j7O7C/GePHq5N/OwHkRIIDz6mtq28uLi3Fx/EZwx+mjJw5jG0+P0vDTmgABtK5XOASeTYAAXAgCwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR4AA3AACwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR4AA3AACwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR4AA3AACwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR4AA3AACwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR4AA3AACwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR4AA3AACwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR4AA3AACwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR4AA3AACwQQIILh80REgADeAQDABAgguX3QECMANIBBMgACCyxcdAQJwAwgEEyCA4PJFR+C/PoYml4nIu8YAAAAASUVORK5CYII=" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/highlight.css">

  
  <script src="/js/quotes.js"></script>
  <meta name="description" content="在《写一个自己的UnixShell（1）搭建一个框架》这篇文章中，我们实现了一个基本的Shell程序框架，从终端中不断读取一行字符并打印的功能。接下来我们实现将读取的字符变为命令，在终端可以看到我们命令执行的结果的功能。就像下面图示中这样。  进入主题前，我们先看几个前置知识 什么是程序，什么是进程 简单来说，程序就是存放在磁盘中的可以被我们执行的文件和一些其他的资源文件的集合，它们就静静地躺在磁">
<meta property="og:type" content="article">
<meta property="og:title" content="写一个自己的Unix Shell（2）将读入的字符变成命令">
<meta property="og:url" content="http://example.com/2024/08/17/%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84UnixShell-2/index.html">
<meta property="og:site_name" content="Lcf&#39;s Blog">
<meta property="og:description" content="在《写一个自己的UnixShell（1）搭建一个框架》这篇文章中，我们实现了一个基本的Shell程序框架，从终端中不断读取一行字符并打印的功能。接下来我们实现将读取的字符变为命令，在终端可以看到我们命令执行的结果的功能。就像下面图示中这样。  进入主题前，我们先看几个前置知识 什么是程序，什么是进程 简单来说，程序就是存放在磁盘中的可以被我们执行的文件和一些其他的资源文件的集合，它们就静静地躺在磁">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lcf-resources.oss-cn-beijing.aliyuncs.com/resources/Kapture%202024-08-17%20at%2018.16.17.gif">
<meta property="og:image" content="https://lcf-resources.oss-cn-beijing.aliyuncs.com/resources/2024-08-25_21-46.png">
<meta property="og:image" content="https://lcf-resources.oss-cn-beijing.aliyuncs.com/resources/2024-08-25_01-15.png">
<meta property="article:published_time" content="2024-08-17T09:37:37.000Z">
<meta property="article:modified_time" content="2024-08-25T14:33:46.436Z">
<meta property="article:author" content="longrichli">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="写一个自己的Unix Shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lcf-resources.oss-cn-beijing.aliyuncs.com/resources/Kapture%202024-08-17%20at%2018.16.17.gif"><meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">Lcf&#39;s Blog</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">|</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
  <div>
      <!-- <a href="javascript: void(0)" id=""></a> -->
      <div id="quote" class="article-entry"></div>
      <div id="author" class="article-entry"></div>
  </div>
  
</header>

    <div id="content">
      <article id="post-写一个自己的UnixShell-2" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      写一个自己的Unix Shell（2）将读入的字符变成命令
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2024-08-17T09:37:37.000Z" itemprop="datePublished">2024-08-17 05:37 pm</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <p>        在《写一个自己的UnixShell（1）搭建一个框架》这篇文章中，我们实现了一个基本的Shell程序框架，从终端中不断读取一行字符并打印的功能。接下来我们实现将读取的字符变为命令，在终端可以看到我们命令执行的结果的功能。就像下面图示中这样。</p>
<img src="https://lcf-resources.oss-cn-beijing.aliyuncs.com/resources/Kapture%202024-08-17%20at%2018.16.17.gif" title="" alt="" data-align="center">

<h2 id="进入主题前，我们先看几个前置知识"><a href="#进入主题前，我们先看几个前置知识" class="headerlink" title="进入主题前，我们先看几个前置知识"></a>进入主题前，我们先看几个前置知识</h2><h3 id="什么是程序，什么是进程"><a href="#什么是程序，什么是进程" class="headerlink" title="什么是程序，什么是进程"></a>什么是程序，什么是进程</h3><p>        简单来说，程序就是存放在磁盘中的可以被我们执行的文件和一些其他的资源文件的集合，它们就静静地躺在磁盘中，等待着被运行。而进程就是进行中的程序，已经运行起来的程序。进程之间是相互独立的，比如运行起来的QQ和运行起来的微信，它们俩都是进程，但互不干扰，相互独立。</p>
<h3 id="进程也可以创建进程"><a href="#进程也可以创建进程" class="headerlink" title="进程也可以创建进程"></a>进程也可以创建进程</h3><p>        正如人可以生小孩一样，进程也可以生孩子进程，我们把进程A创建的进程B叫进程A的子进程，进程A叫进程B的父进程。正如人生小孩会把父母的遗传物质给孩子，子进程也会有父进程的内存等资源信息，但父子进程已经是不同的进程了，它们可以做不同的事了。</p>
<h3 id="如何创建子进程"><a href="#如何创建子进程" class="headerlink" title="如何创建子进程"></a>如何创建子进程</h3><p>        我们通过<code>fork()</code>系统调用（操作系统提供的API，在我们调用时就像调用一个函数）来创建子进程，下面来看看<code>fork()</code>函数的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span>     <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>        <code>fork()</code>函数的声明在&lt;unistd.h&gt;头文件中。<code>fork()</code>函数返回子进程的进程ID（pid_t） , pid_t 是一个有符号整数。<code>fork()</code>函数返回两次，一次是父进程返回，一次是子进程返回，父进程返回时，返回的pid_t 大于0，子进程返回时，返回的pid_t 等于0。（因为<code>fork()</code>函数的返回值是子进程的进程ID，父进程刚生完孩子有子进程的进程ID，子进程没生孩子，所以子进程返回的pid_t 是0）当<code>fork()</code>函数返回的pid_t 小于0时，说明父进程没有把孩子生下来，难产了（发生了错误）。</p>
<h3 id="父进程等待子进程退出"><a href="#父进程等待子进程退出" class="headerlink" title="父进程等待子进程退出"></a>父进程等待子进程退出</h3><p>        在Shell程序中，我们需要父进程等待它创建的子进程退出后在执行，为什么呢？因为在Shell程序中，Shell程序本身是一个父进程，而我们输入的命令的执行是由子进程来完成的。拿<code>ls</code>命令来举例，我们输入<code>ls</code>命令后，终端会打印当前目录下的文件列表，打印当前目录下的文件列表这个功能是在Shell程序创建出的子进程中完成的，当子进程打印完当前目录下的文件列表后，父进程也就是Shell程序再输出类似 <code>myshell# </code>这样的字符串等待下一个命令。如果父进程不等待子进程退出，继续往下执行，可能子进程还没有打印出当前目录下的文件列表，父进程就把<code>myshell# </code>串输出了，这样显然是不对的。所以我们需要让父进程等待子进程退出后再继续执行。我们用<code>wait()</code>系统调用来实现这样的功能。下面来看看<code>wait()</code>函数的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span>   <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span></span><br></pre></td></tr></table></figure>

<p>        <code>wait()</code>系统调用在&lt;sys&#x2F;wait.h&gt;头文件中声明。<code>wait()</code>系统调用使父进程等待它的任意一个子进程退出后再继续执行，否则父进程会一直阻塞在那里。<code>wait()</code>系统调用返回结束的子进程的进程ID，如果返回-1，说明出错了。参数status用于存放子进程退出时的状态（成功，失败等），如果我们不关心子进程的退出状态，我们可以将status参数置为NULL。当然，<code>wait()</code>还有一个释放子进程资源的功能，否则子进程就成了“僵尸进程”（进程退出了，但资源没释放，半死不活的进程）。</p>
<h3 id="改写《写一个自己的UnixShell（1）搭建一个框架》中的程序，使用创建子进程实现"><a href="#改写《写一个自己的UnixShell（1）搭建一个框架》中的程序，使用创建子进程实现" class="headerlink" title="改写《写一个自己的UnixShell（1）搭建一个框架》中的程序，使用创建子进程实现"></a>改写《写一个自己的UnixShell（1）搭建一个框架》中的程序，使用创建子进程实现</h3><p>        下面我们把《写一个自己的UnixShell（1）搭建一个框架》这篇文章中实现的打印一行字符的功能通过创建子进程来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *cmdString = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">ssize_t</span> nread = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;myshell# &quot;</span>);</span><br><span class="line">        nread = getline(&amp;cmdString, <span class="literal">NULL</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span>(nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;main() getline()\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(cmdString != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(cmdString);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nBey~\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cmdString == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;main() cmdString = NULL\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSpaceStr(cmdString) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(cmdString);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%s&quot;, cmdString);</span></span><br><span class="line">        <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//创建子进程</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;main() fork()\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(cmdString);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程打印字符串</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cmdString);</span><br><span class="line">            <span class="comment">// 释放子进程的内存，不会影响父进程</span></span><br><span class="line">            <span class="keyword">if</span>(cmdString != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(cmdString);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子进程退出</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父进程等待子进程退出</span></span><br><span class="line">        <span class="keyword">if</span>(wait(<span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;main() wait()&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(cmdString);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cmdString != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(cmdString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        我们只需将<code>fork()</code>和<code>wait()</code>系统调用放入<code>main()</code>函数中即可实现在子进程打印一行字符的功能。</p>
<h3 id="调用其它程序"><a href="#调用其它程序" class="headerlink" title="### 调用其它程序"></a>### 调用其它程序</h3><p>        我们输入进Shell程序中的命令都是Shell程序来实现的吗？当然不是，实际上，正如Shell的中文翻译”壳”一样，Shell程序就是一个外壳，它不负责命令的具体实现，它是通过调用其它程序来实现这些命令的。例如在系统的<code>/usr/bin/</code> 或 <code>/usr/sbin/</code> 等目录下，就存放着许多命令的具体实现程序，Shell程序正是通过调用它们来实现功能的。</p>
<p>        系统调用<code>execve()</code>可以将新程序加载到调用进程的内存空间，替换调用进程的原有部件，新的进程就可以从<code>main()</code>函数执行了。我们来看一看<code>execve()</code>系统调用的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>     <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __file, <span class="type">char</span> * <span class="type">const</span> * __argv, <span class="type">char</span> * <span class="type">const</span> * __envp)</span></span><br></pre></td></tr></table></figure>

<p>        <code>execve()</code>系统调用在头文件&lt;unistd.h&gt;中声明，<code>__file</code>参数表示新的程序的文件路径；因为新的程序从<code>main()</code>函数开始执行，所以<code>__argv</code>参数相当于<code>int main(int argc, char **argv)</code>函数中的<code>argv</code>参数，程序会将<code>execve()</code>函数中的<code>__argv</code>参数的内容传入新程序的<code>argv</code>参数中，是一个以<code>NULL</code>结尾的字符串数组；<code>__envp</code>参数指定了新的程序的环境列表（什么是环境列表？就是几个类似于<code>name=vlaue</code>的字符串，比如：<code>name=zhangsan</code>、<code>agc=123</code>，起个“环境列表”这个名字显得高大上些），它也是以<code>NULL</code>结尾的字符串数组。    <code>execve()</code>函数（因为调用系统调用和调用函数无异，我们都叫它们函数吧）调用成功不再返回，失败返回-1。下面我们写两个程序来使用一下<code>execve()</code>系统调用。</p>
<p>        程序 test_evecve：调用<code>execve()</code>系统调用来执行程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: test_execve &lt;new progrom path&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新程序的路径</span></span><br><span class="line">    <span class="type">char</span> *newProgramPath = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 设置 execve() 函数的 __argv 参数</span></span><br><span class="line">    <span class="type">char</span> *__argv[<span class="number">10</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    __argv[<span class="number">0</span>] = newProgramPath;</span><br><span class="line">    __argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    __argv[<span class="number">2</span>] = <span class="string">&quot;I am zhang san&quot;</span>;</span><br><span class="line">    __argv[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置 execve() 函数的 __envp 参数</span></span><br><span class="line">    <span class="type">char</span> *__envp[<span class="number">10</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    __envp[<span class="number">0</span>] = <span class="string">&quot;name=zhangsan&quot;</span>;</span><br><span class="line">    __envp[<span class="number">1</span>] = <span class="string">&quot;abc=123&quot;</span>;</span><br><span class="line">    __envp[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 调用 execve() 函数, 调用成功不返回，执行新程序，调用失败返回-1</span></span><br><span class="line">    execve(newProgramPath, __argv, __envp);</span><br><span class="line">    <span class="comment">// 调用失败，打印错误</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;main() execve() failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        程序p_args_envs：打印传入参数和环境列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// 环境列表变量，里面保存着环境列表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印argv</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=========argv=============\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印环境列表</span></span><br><span class="line">    <span class="type">char</span> **ep = environ;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=========envs=============\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(*ep != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;envs[%d]: %s\n&quot;</span>, j, environ[j]);</span><br><span class="line">        j++;</span><br><span class="line">        ep++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        执行 <code>./test_exevce</code>程序，并将传入新程序<code>p_args_envs</code>的相对路径。执行结果如下图。</p>
<p><img src="https://lcf-resources.oss-cn-beijing.aliyuncs.com/resources/2024-08-25_21-46.png"> </p>
<p>        上图就是我们在程序test_execve调用程序p_args_envs，由p_args_envs的打印结果。</p>
<p><code>execve()</code>函数是一个系统调用，也就是操作系统给我们提供的函数，在它之上，还有几个基于<code>execve()</code>系统调用的库函数，被称为<code>exec()</code>库函数（它们的功能都是调用新的程序）。它们的声明如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>     <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __path, <span class="type">const</span> <span class="type">char</span> * __arg0, ...)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __path, <span class="type">const</span> <span class="type">char</span> * __arg0, ...)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __file, <span class="type">const</span> <span class="type">char</span> * __arg0, ...)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __path, <span class="type">char</span> * <span class="type">const</span> * __argv)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __file, <span class="type">char</span> * <span class="type">const</span> * __argv)</span>;</span><br></pre></td></tr></table></figure>

<p>        我们可以看看上面五个函数声明的特点，它们都是以<code>exec</code>来开头，表明它们是<code>exec()</code>库函数，我们还看到有些函数有个<code>l</code>，有些函数有个<code>e</code>,有些函数有个<code>p</code>,有些函数有个<code>v</code>。下面来看看这些字母代表的含义。</p>
<ul>
<li><p><code>l</code>：list的缩写，表示以字符串列表的方式传入。字符串列表具体就是通过可变参数，而不是字符串数组。举个例子，用<code>execl()</code>函数来调用新程序的代码应该类似下面这样写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/new_program_path&quot;</span>, <span class="string">&quot;/new_program_path&quot;</span>, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>当新程序从<code>main()</code>函数执行时，<code>main()</code>函数的argv中存放的有效内容就是<code>execl()</code>函数传入的<code>__arg0</code>和可变参数，上面的例子中就是：<code>&quot;/new_program_path&quot;, &quot;arg1&quot;, &quot;arg2&quot;</code></p>
</li>
<li><p><code>e</code>：envp的缩写，表示传入环境列表，也就是<code>execve()</code>中的第三个参数。举个例子，用<code>execle()</code>函数来调用新程序的的代码应该类似下面这样写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *envp[<span class="number">10</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">envp[<span class="number">0</span>] = <span class="string">&quot;name=zhangsan&quot;</span>；</span><br><span class="line">envp[<span class="number">1</span>] = <span class="string">&quot;abc=123&quot;</span>;</span><br><span class="line">envp[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">execle(<span class="string">&quot;/new_program_path&quot;</span>, </span><br><span class="line">        <span class="string">&quot;/new_program_path&quot;</span>, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>,</span><br><span class="line">        envp);</span><br></pre></td></tr></table></figure>

<p>最后一个参数传入环境列表。<code>exec</code>库函数中没有带e的函数默认将调用进程的变量environ中的内容传给新的程序。</p>
</li>
<li><p><code>p</code>：PATH的缩写，PATH是一个环境变量，就像C语言有全局变量一样，操作系统也有全局变量，不过为了显得高大上些，就把操作系统的全局变量称为环境变量。PATH就是一个环境变量，它的值是一个或多个操作系统的目录字符串，用冒号分割，就像下面这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/bin:/usr/bin:/usr/sbin/:/usr/local/bin</span><br></pre></td></tr></table></figure>

<p>上面的环境变量<code>PATH</code>记录了操作系统的四个路径：“&#x2F;bin”、“&#x2F;usr&#x2F;bin”、”&#x2F;usr&#x2F;sbin“和”&#x2F;usr&#x2F;local&#x2F;bin“。</p>
<p>在<code>exec()</code>库函数中，带有字母p的表示使用环境变量PATH。我们可以直接传入一个文件名，它会去环境PATH的所有目录中去找我们传入的文件名，如果找到了我们传入的文件，并且是可以执行的文件的话，就会执行这个文件。相当于我们不用传入新的程序的完整路径了。当然，如果我们传入的文件名中带有<code>/</code>字符，它还是会按传入了一个路径处理，而不去环境变量PATH中寻找。举个例子：函数<code>execlp()</code>的使用类似于下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-a&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 会到PATH环境变量中的所有目录中去寻找ls这个可执行文件，执行这个可执行文件，</span></span><br><span class="line"><span class="comment">// 并传入-l和-a参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>v</code>：vertor的缩写，中文是“向量”的意思。就是表示用以NULL结尾的字符串数组的方式来向新的程序传入参数列表。举个例子：<code>execvp()</code>函数的使用类似下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">10</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-l&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;-p&quot;</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">execvp(<span class="string">&quot;ls&quot;</span>, argv);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>ok，让我们总结一下<code>exec()</code>函数的差异。</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">对程序文件的描述(-,p)</th>
<th align="center">对参数的描述(l,v)</th>
<th align="center">环境变量的来源(e,-)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">execve()</td>
<td align="center">路径名</td>
<td align="center">数组</td>
<td align="center">envp参数</td>
</tr>
<tr>
<td align="center">execle()</td>
<td align="center">路径名</td>
<td align="center">列表（可变参数）</td>
<td align="center">envp参数</td>
</tr>
<tr>
<td align="center">execlp()</td>
<td align="center">文件名+PATH</td>
<td align="center">列表（可变参数）</td>
<td align="center">调用者的environ</td>
</tr>
<tr>
<td align="center">execvp()</td>
<td align="center">文件名+PATH</td>
<td align="center">数组</td>
<td align="center">调用者的environ</td>
</tr>
<tr>
<td align="center">execv()</td>
<td align="center">路径名</td>
<td align="center">数组</td>
<td align="center">调用者的environ</td>
</tr>
<tr>
<td align="center">execle()</td>
<td align="center">路径名</td>
<td align="center">列表（可变参数）</td>
<td align="center">envp参数</td>
</tr>
</tbody></table>
<h2 id="进入正题，将输入的字符变为命令"><a href="#进入正题，将输入的字符变为命令" class="headerlink" title="进入正题，将输入的字符变为命令"></a>进入正题，将输入的字符变为命令</h2><p>        通过前文所述，我们知道了如何创建子进程，如何调用另一个程序，下面我们就把输入的那一行字符转换成调用其他程序的命令。</p>
<p>        我们用<code>exec()</code>函数中的<code>execvp()</code>函数来实现调用其他程序，这样我们就可以像在真正的Shell程序那样，输入一个文件名，Shell程序去环境变量PATH中所记录的目录中去寻找文件，从而执行了。前文可知，<code>execvp()</code>函数需要两个参数，文件名和参数数组。我们需要将我们输入的字符转成字符串数组的方式供<code>execvp()</code>使用。我们用<code>parseCmdString()</code>函数来实现将输入的字符串转为字符串数组的功能。函数定义如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#defile MAX_COMMAND_LEN（4096）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">des:</span></span><br><span class="line"><span class="comment">    将命令字符串转为字符串数组</span></span><br><span class="line"><span class="comment">param:</span></span><br><span class="line"><span class="comment">    cmdString[IN]: 命令字符串</span></span><br><span class="line"><span class="comment">return:</span></span><br><span class="line"><span class="comment">    成功：以NULL结尾的字符串数组</span></span><br><span class="line"><span class="comment">    失败：NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> **<span class="title function_">parseCmdString</span><span class="params">(<span class="type">char</span> *cmdString)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tokenCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> tempCmdString1[MAX_COMMAND_LEN + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> tempCmdString2[MAX_COMMAND_LEN + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(tempCmdString1, cmdString);</span><br><span class="line">    <span class="built_in">strcpy</span>(tempCmdString2, cmdString);</span><br><span class="line">    <span class="type">char</span> *token = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> **argv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检查字符串长度</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(cmdString) &gt; MAX_COMMAND_LEN) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;parseCmdString() error: The command string is too long\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> __finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分割字符串并计算小字符串数量</span></span><br><span class="line">    token = strtok(tempCmdString1, <span class="string">&quot; \n\r\t&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tokenCount++;</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">&quot; \n\r\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tokenCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;parseCmdString() error: tokenCount = 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> __finish;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    argv = <span class="built_in">malloc</span>((tokenCount + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span> **));</span><br><span class="line">    <span class="keyword">if</span>(argv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;parseCmdString() malloc() error: argv = NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> __finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>; p &lt; tokenCount + <span class="number">1</span>; p++) &#123;</span><br><span class="line">        argv[p] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分割字符串并填充小字符串</span></span><br><span class="line">    token = strtok(tempCmdString2, <span class="string">&quot; \n\r\t&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        argv[i] = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(token) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(argv[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;parseCmdString() malloc() error: argv[%d] = NULL\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">goto</span> __finish;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(argv[i], <span class="number">0</span>, <span class="built_in">strlen</span>(token) + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(argv[i], token);</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">&quot; \n\r\t&quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">__finish:</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span> &amp;&amp; argv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokenCount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(argv[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret == <span class="number">0</span> ? argv : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        在上面的函数中，我们对输入的字符串的长度做了限定，它的长度不能超过4096字节，然后将输入的字符串按空格，换行符，回车符和制表符分割成一个一个小字符串（比如字符串“ls -l -a”被分割为“ls”、“-l”和 “-a”），然后计算小字符串的数量，创建一个容量为字符串数量+1的字符串数组，多一个用来存放NULL（<code>execvp</code>的<code>__argv</code>参数要求是以NULL结尾的字符串数组）。最后将每个小字符串复制到字符串数组中，返回这个字符串数组。这样我们就完成了从输入字符串到字符串数组的转变。</p>
<p>        接下来我们实现调用其他程序来执行我们的命令。我们用<code>execCommand()</code>函数来实现这个功能。下面是<code>execCommand()</code>函数的定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">des:</span></span><br><span class="line"><span class="comment">    执行命令</span></span><br><span class="line"><span class="comment">param: </span></span><br><span class="line"><span class="comment">    cmdString[IN]: 命令字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">execCommand</span><span class="params">(<span class="type">char</span> *cmdString)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;execCommand() fork() error\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 获取argv数组</span></span><br><span class="line">        <span class="type">char</span> *<span class="type">const</span> *argv = <span class="literal">NULL</span>;</span><br><span class="line">        argv = parseCmdString(cmdString);</span><br><span class="line">        <span class="keyword">if</span>(argv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;execCommand() parseCmdString() error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行execvp函数调用其他程序</span></span><br><span class="line">        <span class="keyword">if</span>(execvp(argv[<span class="number">0</span>], argv) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;myshell&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程等待子进程退出</span></span><br><span class="line">        <span class="keyword">if</span>(wait(<span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;execCommand() wait() error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        经过前面的讲解，上面的代码应该很容易理解了，上面的代码中，父进程用<code>fork()</code>系统调用创建了子进程，在子进程中先将我们输入的字符串转成了字符串数组，然后调用<code>evecvp()</code>函数执行我们字符串中指定的新的程序，父进程等待新的程序退出后返回。</p>
<p>        最后，我们改一下《写一个自己的UnixShell（1）搭建一个框架》文章中的<code>main()</code>函数，让它调用<code>execCommand()</code>函数就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *cmdString = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">ssize_t</span> nread = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;myshell# &quot;</span>);</span><br><span class="line">        nread = getline(&amp;cmdString, <span class="literal">NULL</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span>(nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;main() getline()\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(cmdString != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(cmdString);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nBey~\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cmdString == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;main() cmdString = NULL\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSpaceStr(cmdString) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(cmdString);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里判断一下输入字符的数量是否超出限制</span></span><br><span class="line">        <span class="keyword">if</span>(nread &gt; MAX_COMMAND_LEN) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;myshell: The command is too long\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(cmdString);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        execCommand(cmdString);</span><br><span class="line">        <span class="keyword">if</span>(cmdString != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(cmdString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        现在，当我们输入<code>ls</code>等命令时，程序会调用<code>execCommand()</code>函数创建子进程，在子进程中将<code>ls</code>转成字符串数组，然后调用<code>execvp()</code>函数通过环境变量的PATH中的目录找到<code>ls</code>的可执行文件执行它。父进程等待<code>ls</code>的程序执行完毕后，打印出<code>myshell# </code>字符串后等待下一次的输入。</p>
<p>        以上，便完成了我们制作自己的Unix Shell的第二步：将读入的字符变成命令。</p>
<p>附：</p>
<p>        欢迎大家关注我的微信公众号^_^。</p>
<img title="" src="https://lcf-resources.oss-cn-beijing.aliyuncs.com/resources/2024-08-25_01-15.png" alt="" width="417" data-align="center">

      
    </div>
    
    
    <div class="article-category">
      
      
      
        <b>Tags:</b>
        <a class="article-tag-none-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a>, <a class="article-tag-none-link" href="/tags/%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84Unix-Shell/" rel="tag">写一个自己的Unix Shell</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <span id="article-nav-newer" class="article-nav-link-wrap newer"></span>
  
  
    <a href="/2024/08/15/%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84UnixShell-1/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          写一个自己的Unix Shell（1）搭建一个框架
        
      </div>
    </a>
  
</nav>




  <!-- <script>
  var idcomments_acct = '00000000000000000000000000000001';
  var idcomments_post_id;
  var idcomments_post_url;
  </script>
  <span id="IDCommentsPostTitle" style="display:none"></span>
  <script type='text/javascript' src='https://www.intensedebate.com/js/genericCommentWrapperV2.js'></script> -->
  <div id="gitalk-container"></div>
  <script src="/js/md5.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script>
      var gitalk = new Gitalk({
      clientID: 'Ov23lilyHLOdLBrFF3yy',
      clientSecret: '7822a963c115ba84b0c9b85f311abd46afa24dc6',
      repo: 'BlogCommends',
      owner: 'longrichli',
      admin: ['longrichli'],
      id: md5(location.pathname),      // Ensure uniqueness and length less than 50
      distractionFreeMode: false  // Facebook-like distraction free mode
      })
      gitalk.render('gitalk-container')
  </script>



    </div>
  </div>
  
  
<link rel="stylesheet" href="/css/comments.css">






<div id="settings-container">
  <div id="dark-mode">dark</div>
  <hr>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#bbb');f('--secondary-color','#707070');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




</body>
</html>
